using LinearAlgebra, DataFrames, JuMP, GLPK

# Assignment function 
function Assignment(b, T, d, R, c, Φ)
    M = Model(GLPK.Optimizer)
    @variable(M, x[keys(b)] >= 0)
    @variable(M, y[keys(b)], Bin)
    @objective(M, Max, sum( x[k] * Φ[k] for k in keys(b)))
    #   Capacity constraints
    @constraint(M, cap[i ∈ T], sum(d[j] * x[(i,j)] for j ∈ R if (i,j) in keys(b)) <= c[i])
    # Demand
    @constraint(M, dem[j ∈ R], sum(x[(i,j)] for i ∈ T if (i,j) in keys(b)) == 1)
    # At least 2 shipping companies per route
    @constraint(M, min_companiesperroute[j ∈ R], sum(y[(i,j)] for i ∈ T if (i,j) in keys(b)) >= 2)
    # A company will receive a percentage if and only if it participates in the bidding
    @constraint(M, bidding[(i,j) ∈ keys(b)], y[(i,j)] <= b[(i,j)])
    # A shipping company should not receive less than 10% of the demand on the route
    @constraint(M, atleast[(i,j) ∈ keys(b)],  x[(i,j)] >= 0.1 * y[(i,j)])
    # A shipping company should not more than 40% 
    @constraint(M, lessthan[(i,j) ∈ keys(b)],  x[(i,j)] <= 0.4 * y[(i,j)])
    optimize!(M)
    x_, y_, z_ = value.(x), value.(y), objective_value(M)
    return M, x_, y_, z_
end


# BWM-PROMETHEE-II function
function BWM_PROMETHEE_NetFlows(best, worst, b_comparisons, w_comparisons, 
    Decision_Matrix::Matrix, q_thresholds::Vector, p_thresholds::Vector, 
    scurve_thresholds::Vector, pref_fn::Vector; alternative_names=nothing)
    
    #=
    This function returns the flows generate after applying PROMETHEE II with BWM weights
    inputs:
        best: indicates the index of the best criterion 
        worst: indicates the index of the worst criterion
        b_comparisons: array with the comparison values of the best criterion regarding the criteria set 
        w_comparisons: array with the comparison values of the criteria set in relation to the worst one
        Decision_Matrix - matrix of size=(m,n) with the performances of $m$ alternatives regarding $n$ criteria.
        q_thresholds - a n-dimensional vector receiving indifference thresholds for the criteria
        p_thresholds - a n-dimensional vector receiving preference thresholds for the criteria
        scurve_thresholds- a n-dimensional vector receiving the scurve thresholds to be used in case the Gaussian function is chosen
        weights: a n-dimensional vector receiving weights for the criteria
        pref_function: a n-dimensional vector receiving as input integers between 1 and 6 that indicate the preference function for each criterion 
        alternative_names - vector of strings receiving the name of the alternatives
    
    Possible outputs:
        weights_: n-dimensional vector of weights generated by BWM
        e_: float with the consistence metric of BWM
        net_flows: m-dimensional vector of net flows
    =#

    n= length(b_comparisons)
    # BWM model
    M = Model(GLPK.Optimizer)  # Model 
    @variable(M, weights[1:n] >= 0)
    @variable(M, e >= 0)
    @objective(M, Min, e) 
    @constraint(M, [j in 1:n], weights[best] - b_comparisons[j] * weights[j] <= e) # related to the best criterion
    @constraint(M, [j in 1:n], - weights[best] + b_comparisons[j] * weights[j] <= e) # related to the best criterion
    @constraint(M, [j in 1:n], weights[j] - w_comparisons[j] * weights[worst] <= e) # related to the worst criterion
    @constraint(M, [j in 1:n], - weights[j] + w_comparisons[j] * weights[worst] <= e) # related to the worst criterion
    @constraint(M, sum(weights[j] for j in 1:n) == 1)
    optimize!(M)
    weights_ = value.(weights); e_ = value(e);

    # PROMETHEE Model
    m, n = size(Decision_Matrix) #m is the number of alternatives, n is the number of criteria
    if  isnothing(alternative_names)
        alternative_names = ["a_" * string(i) for i in 1:m]
    end
    D = zeros(m,m,n) # 3-dimensional array that will receive n matrices (mxm) of pairwise differences 
    P = zeros(m,m,n) # 3-dimensional array that will receive n matrices (mxm) of preference functions according with the given p_thresholds
    for j in 1:n
        for u in 1:m
            for v in 1:m
                D[u,v,j] = Decision_Matrix[u,j] - Decision_Matrix[v,j]
                
                if pref_fn[j] == 1 D[u,v,j] <=0 ? P[u,v,j] = 0 : P[u,v,j] = 1 end              
                if pref_fn[j] == 2 D[u,v,j] <= q_thresholds[j] ? P[u,v,j] = 0 : P[u,v,j] = 1 end
                if pref_fn[j] == 3 D[u,v,j] <= 0 ? P[u,v,j] = 0 : 
                    D[u,v,j] <= p_thresholds[j] ? P[u,v,j] = D[u,v,j]/p_thresholds[j] : 
                    P[u,v,j] = 1 
                end
                if pref_fn[j] == 4 D[u,v,j] <= q_thresholds[j] ? P[u,v,j] = 0 : 
                    D[u,v,j] <= p_thresholds[j] ? P[u,v,j] = 0.5 : P[u,v,j] = 1 
                end
                
                if pref_fn[j] == 5 D[u,v,j] <= q_thresholds[j] ? P[u,v,j] = 0 : 
                D[u,v,j] <= p_thresholds[j] ? P[u,v,j]=(D[u,v,j]-q_thresholds[j])/(p_thresholds[j]-q_thresholds[j]) : 
                P[u,v,j] = 1 
                end
                if pref_fn[j] == 6 D[u,v,j] <=0 ? P[u,v,j] = 0 : P[u,v,j] = 1 - exp(-(D[u,v,j]^2 / 2*scurve_thresholds[j]^2)) end              
            end
        end    
    end       
    Aggregated_P = zeros(m,m)
    for u in 1:m
        for v in 1:m
            Aggregated_P[u,v] = dot(P[u,v,:], weights_)     
        end 
    end
    #Aggregated_P = DataFrames(Aggregated_P)
    pos_flows = [sum(Aggregated_P[i,:]) / (m-1) for i in 1:m] # Vector of positive flows
    neg_flows = [sum(Aggregated_P[:,j]) / (m-1) for j in 1:m] # Vector of negative flows
    net_flows = pos_flows - neg_flows
    flows_df = DataFrame(Alternative = alternative_names,
                        Positive_flows = pos_flows,
                        Negative_flows = neg_flows,
                        Net_flows = net_flows)
    return weights_, e_, net_flows
end

